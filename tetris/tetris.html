<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>俄罗斯方块 - Tetris</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation; /* 防止双击缩放 */
        }

        body {
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        /* 顶部导航 */
        .header {
            width: 100%;
            max-width: 500px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            margin-bottom: 10px;
        }

        .back-btn {
            text-decoration: none;
            color: #a0a0a0;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            transition: color 0.3s;
        }

        .back-btn:hover {
            color: #fff;
        }

        .game-title {
            font-size: 1.5rem;
            background: linear-gradient(90deg, #9b59b6, #8e44ad);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: bold;
        }

        /* 游戏主容器 */
        .game-container {
            position: relative;
            display: flex;
            gap: 20px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }

        canvas {
            background-color: #000;
            border: 2px solid #333;
            border-radius: 4px;
            display: block;
        }

        /* 侧边信息栏 */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-width: 100px;
        }

        .info-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .info-label {
            font-size: 0.8rem;
            color: #aaa;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #fff;
        }

        /* 下一个方块预览 */
        .next-piece-container {
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #next-canvas {
            background-color: #000;
            border: 2px solid #333;
            border-radius: 4px;
            margin-top: 5px;
        }

        .controls-hint {
            font-size: 0.8rem;
            color: #888;
            line-height: 1.5;
            display: none; /* 移动端隐藏，桌面端显示 */
        }

        /* 移动端控制按钮 */
        .mobile-controls {
            display: none; /* 默认隐藏，媒体查询开启 */
            margin-top: 20px;
            width: 100%;
            max-width: 400px;
            gap: 15px; /* 增加间距 */
            padding: 0 20px;
            /* 确保在最上层 */
            position: relative;
            z-index: 100;
        }

        .control-row {
            display: flex;
            justify-content: center;
            gap: 25px; /* 增加按钮间距 */
            width: 100%;
        }

        .d-pad-btn {
            width: 65px;
            height: 65px;
            border-radius: 50%;
            /* 显著加深背景颜色，提高可见度 */
            background: rgba(255, 255, 255, 0.25);
            /* 加粗边框 */
            border: 2px solid rgba(255, 255, 255, 0.6);
            color: white;
            font-size: 1.8rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            transition: all 0.1s;
            /* 增加阴影，使其更立体 */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            /* 确保点击区域足够大 */
            touch-action: none; 
        }

        .d-pad-btn:active {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(0.95);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        /* 旋转按钮特殊颜色 */
        #btn-rotate {
            background: rgba(155, 89, 182, 0.4); /* 紫色系 */
            border-color: rgba(155, 89, 182, 0.8);
        }

        /* 下落按钮特殊颜色 */
        #btn-down {
            background: rgba(52, 152, 219, 0.4); /* 蓝色系 */
            border-color: rgba(52, 152, 219, 0.8);
        }

        /* 遮罩层 (开始/暂停/结束) */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            border-radius: 15px;
        }

        .overlay h2 {
            font-size: 2rem;
            margin-bottom: 20px;
            color: #9b59b6;
        }

        .btn {
            padding: 10px 30px;
            font-size: 1.2rem;
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            border: none;
            border-radius: 25px;
            color: white;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 15px rgba(155, 89, 182, 0.4);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(155, 89, 182, 0.6);
        }

        /* 难度选择按钮组 */
        .diff-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            background: rgba(0, 0, 0, 0.3);
            padding: 5px;
            border-radius: 25px;
        }

        .diff-btn {
            padding: 8px 20px;
            border: none;
            border-radius: 20px;
            background: transparent;
            color: #aaa;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1rem;
        }

        .diff-btn.active {
            background: #9b59b6;
            color: #fff;
            box-shadow: 0 2px 10px rgba(155, 89, 182, 0.4);
        }

        /* 响应式适配 */
        @media (min-width: 769px) {
            .controls-hint {
                display: block;
            }
        }

        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
                align-items: center;
            }

            .sidebar {
                flex-direction: row;
                width: 100%;
                justify-content: space-around;
            }

            .info-box {
                padding: 10px;
                min-width: 80px;
            }

            .info-value {
                font-size: 1.2rem;
            }
            
            .controls-hint {
                display: none;
            }

            .mobile-controls {
                display: flex;
                flex-direction: column;
            }
        }
    </style>
</head>
<body>

    <div class="header">
        <a href="../index.html" class="back-btn">
            ← 返回
        </a>
        <div class="game-title">TETRIS</div>
        <div style="width: 40px;"></div> <!-- 占位保持居中 -->
    </div>

    <div class="game-container">
        <canvas id="tetris" width="240" height="400"></canvas>
        
        <div class="sidebar">
            <div class="info-box">
                <div class="info-label">分数</div>
                <div class="info-value" id="score">0</div>
            </div>
            <div class="info-box">
                <div class="info-label">等级</div>
                <div class="info-value" id="level">1</div>
            </div>
            
            <div class="info-box next-piece-container">
                <div class="info-label">下一个</div>
                <canvas id="next-canvas" width="80" height="80"></canvas>
            </div>

            <div class="info-box controls-hint">
                <div class="info-label">操作指南</div>
                <div style="text-align: left; color: #ccc; margin-top: 5px; font-size: 0.75rem;">
                    ↑ : 旋转<br>
                    ← → : 移动<br>
                    ↓ : 加速<br>
                    空格 : 暂停
                </div>
            </div>
        </div>

        <div class="overlay" id="start-screen">
            <h2>俄罗斯方块</h2>
            <div class="diff-group">
                <button class="diff-btn" onclick="selectSpeed('slow')">慢速</button>
                <button class="diff-btn active" onclick="selectSpeed('normal')">中速</button>
                <button class="diff-btn" onclick="selectSpeed('fast')">快速</button>
            </div>
            <p style="color: #aaa; margin-bottom: 20px; font-size: 0.9rem;" id="speed-desc">初始速度: 标准</p>
            <div style="display:flex; gap:10px;">
                <button class="btn" onclick="startGame()">开始游戏</button>
                <button class="btn" style="background: #f39c12;" onclick="Leaderboard.show('tetris')">排行榜</button>
            </div>
        </div>

        <div class="overlay" id="game-over-screen" style="display: none;">
            <h2 style="color: #e74c3c;">游戏结束</h2>
            <p style="margin-bottom: 20px; font-size: 1.2rem;">最终得分: <span id="final-score">0</span></p>
            <div style="display:flex; gap:10px;">
                <button class="btn" onclick="resetGame()">重新开始</button>
                <button class="btn" style="background: #f39c12;" onclick="Leaderboard.show('tetris')">排行榜</button>
            </div>
        </div>
        
        <div class="overlay" id="pause-screen" style="display: none;">
            <h2>已暂停</h2>
            <button class="btn" onclick="togglePause()">继续</button>
        </div>
    </div>

    <!-- 移动端控制器 -->
    <div class="mobile-controls">
        <div class="control-row">
            <div class="d-pad-btn" id="btn-rotate">↻</div>
        </div>
        <div class="control-row">
            <div class="d-pad-btn" id="btn-left">←</div>
            <div class="d-pad-btn" id="btn-down">↓</div>
            <div class="d-pad-btn" id="btn-right">→</div>
        </div>
    </div>

    <!-- 引入排行榜模块 -->
    <script src="../leaderboard.js"></script>

    <script>
        const canvas = document.getElementById('tetris');
        const context = canvas.getContext('2d');
        const nextCanvas = document.getElementById('next-canvas');
        const nextContext = nextCanvas.getContext('2d');
        
        const scoreElement = document.getElementById('score');
        const finalScoreElement = document.getElementById('final-score');
        const levelElement = document.getElementById('level');

        // 放大倍数 (20px 一格)
        context.scale(20, 20);
        nextContext.scale(20, 20); // 预览区也放大

        // 消除行数对应的分数: 1行, 2行, 3行, 4行
        const POINTS = [0, 100, 300, 500, 800];

        // 速度配置
        const SPEED_CONFIG = {
            slow: { delay: 1000, label: '初始速度: 悠闲' },
            normal: { delay: 600, label: '初始速度: 标准' },
            fast: { delay: 300, label: '初始速度: 极速' }
        };
        const MIN_DROP_INTERVAL = 100; // 最快 100ms (速度上限)
        
        let currentSpeedMode = 'normal';
        let initialDropInterval = SPEED_CONFIG.normal.delay;

        // 游戏状态
        let dropCounter = 0;
        let dropInterval = 1000;
        let lastTime = 0;
        let isPaused = false;
        let isGameOver = false;
        let animationId = null;

        // 方块定义 (I, J, L, O, S, T, Z)
        const PIECES = 'ILJOTSZ';
        const COLORS = [
            null,
            '#FF0D72', // T - Magenta
            '#0DC2FF', // I - Cyan
            '#0DFF72', // S - Green
            '#F538FF', // Z - Purple (Custom) -> actually standard is Red/Green, let's adjust visually pleasant ones
            '#FF8E0D', // L - Orange
            '#FFE138', // O - Yellow
            '#3877FF', // J - Blue
        ];

        // 调整颜色以匹配霓虹风格
        const NEON_COLORS = [
            null,
            '#9b59b6', // T - Purple
            '#3498db', // I - Blue
            '#2ecc71', // S - Green
            '#e74c3c', // Z - Red
            '#e67e22', // L - Orange
            '#f1c40f', // O - Yellow
            '#1abc9c', // J - Teal
        ];

        function createPiece(type) {
            if (type === 'I') {
                return [
                    [0, 1, 0, 0],
                    [0, 1, 0, 0],
                    [0, 1, 0, 0],
                    [0, 1, 0, 0],
                ];
            } else if (type === 'L') {
                return [
                    [0, 2, 0],
                    [0, 2, 0],
                    [0, 2, 2],
                ];
            } else if (type === 'J') {
                return [
                    [0, 3, 0],
                    [0, 3, 0],
                    [3, 3, 0],
                ];
            } else if (type === 'O') {
                return [
                    [4, 4],
                    [4, 4],
                ];
            } else if (type === 'Z') {
                return [
                    [5, 5, 0],
                    [0, 5, 5],
                    [0, 0, 0],
                ];
            } else if (type === 'S') {
                return [
                    [0, 6, 6],
                    [6, 6, 0],
                    [0, 0, 0],
                ];
            } else if (type === 'T') {
                return [
                    [0, 7, 0],
                    [7, 7, 7],
                    [0, 0, 0],
                ];
            }
        }

        // 创建矩阵 (游戏板)
        function createMatrix(w, h) {
            const matrix = [];
            while (h--) {
                matrix.push(new Array(w).fill(0));
            }
            return matrix;
        }

        // 绘制逻辑
        function draw() {
            // 清空画布 (黑色背景)
            context.fillStyle = '#000';
            context.fillRect(0, 0, canvas.width, canvas.height);

            drawMatrix(arena, {x: 0, y: 0}, context);
            drawMatrix(player.matrix, player.pos, context);
            
            // 绘制警戒线 (在第2行位置)
            // 游戏区域一般有隐藏的顶部行，这里假设可视化区域从第0行开始
            // 绘制一条红色的虚线
            context.beginPath();
            context.strokeStyle = 'rgba(231, 76, 60, 0.5)'; // 红色半透明
            context.lineWidth = 0.1;
            context.setLineDash([0.2, 0.2]); // 虚线模式
            context.moveTo(0, 2); // y=2 的位置
            context.lineTo(arena[0].length, 2);
            context.stroke();
            context.setLineDash([]); // 重置虚线
        }

        // 绘制预览
        function drawNext() {
            nextContext.fillStyle = '#000';
            nextContext.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            
            if (player.next) {
                // 计算居中偏移
                const offsetX = (4 - player.next[0].length) / 2;
                const offsetY = (4 - player.next.length) / 2;
                drawMatrix(player.next, {x: offsetX, y: offsetY}, nextContext);
            }
        }

        function drawMatrix(matrix, offset, ctx) {
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        // 绘制方块
                        ctx.fillStyle = NEON_COLORS[value];
                        ctx.fillRect(x + offset.x, y + offset.y, 1, 1);
                        
                        // 绘制边框效果
                        ctx.lineWidth = 0.05;
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.strokeRect(x + offset.x, y + offset.y, 1, 1);
                        
                        // 内部高光
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                        ctx.fillRect(x + offset.x + 0.1, y + offset.y + 0.1, 0.8, 0.8);
                    }
                });
            });
        }

        // 合并方块到游戏板
        function merge(arena, player) {
            player.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        arena[y + player.pos.y][x + player.pos.x] = value;
                    }
                });
            });
        }

        // 旋转
        function rotate(matrix, dir) {
            for (let y = 0; y < matrix.length; ++y) {
                for (let x = 0; x < y; ++x) {
                    [
                        matrix[x][y],
                        matrix[y][x],
                    ] = [
                        matrix[y][x],
                        matrix[x][y],
                    ];
                }
            }
            if (dir > 0) {
                matrix.forEach(row => row.reverse());
            } else {
                matrix.reverse();
            }
        }

        // 碰撞检测
        function collide(arena, player) {
            const m = player.matrix;
            const o = player.pos;
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0 &&
                       (arena[y + o.y] &&
                        arena[y + o.y][x + o.x]) !== 0) {
                        return true;
                    }
                }
            }
            return false;
        }

        // 消除行
        function arenaSweep() {
            let rowCount = 0;
            outer: for (let y = arena.length - 1; y > 0; --y) {
                for (let x = 0; x < arena[y].length; ++x) {
                    if (arena[y][x] === 0) {
                        continue outer;
                    }
                }

                const row = arena.splice(y, 1)[0].fill(0);
                arena.unshift(row);
                ++y;
                rowCount++;
            }
            
            if (rowCount > 0) {
                // 计算分数 (基于等级和行数)
                // 简单起见，仅基于行数
                const points = POINTS[rowCount] * (player.level || 1);
                player.score += points;
                updateScore();
                
                // 升级逻辑：每1000分升一级
                const newLevel = Math.floor(player.score / 1000) + 1;
                if (newLevel > player.level) {
                    player.level = newLevel;
                    levelElement.innerText = player.level;
                    
                    // 速度随等级提升：指数衰减，但有上限 (MIN_DROP_INTERVAL)
                    // 公式：当前速度 = 初始速度 * (0.9 ^ (level - 1))
                    let newInterval = initialDropInterval * Math.pow(0.9, player.level - 1);
                    dropInterval = Math.max(MIN_DROP_INTERVAL, Math.floor(newInterval));
                }
            }
        }

        // 玩家重置 (新方块)
        function playerReset() {
            const pieces = PIECES;
            
            // 如果没有下一个方块(刚开始)，先生成一个
            if (!player.next) {
                player.next = createPiece(pieces[pieces.length * Math.random() | 0]);
            }
            
            // 当前方块 = 下一个方块
            player.matrix = player.next;
            // 生成新的下一个方块
            player.next = createPiece(pieces[pieces.length * Math.random() | 0]);
            
            // 更新预览
            drawNext();

            player.pos.y = 0;
            player.pos.x = (arena[0].length / 2 | 0) -
                           (player.matrix[0].length / 2 | 0);
            
            // 游戏结束检测
            if (collide(arena, player)) {
                gameOver();
            }
        }

        function gameOver() {
            isGameOver = true;
            cancelAnimationFrame(animationId);
            document.getElementById('game-over-screen').style.display = 'flex';
            finalScoreElement.innerText = player.score;
            
            // 提交成绩
            Leaderboard.submit('tetris', player.score, `${player.score}分`);
        }

        function playerDrop() {
            player.pos.y++;
            if (collide(arena, player)) {
                player.pos.y--;
                merge(arena, player);
                playerReset();
                arenaSweep();
                updateScore();
            }
            dropCounter = 0;
        }

        function playerMove(dir) {
            player.pos.x += dir;
            if (collide(arena, player)) {
                player.pos.x -= dir;
            }
        }

        function playerRotate(dir) {
            const pos = player.pos.x;
            let offset = 1;
            rotate(player.matrix, dir);
            while (collide(arena, player)) {
                player.pos.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                if (offset > player.matrix[0].length) {
                    rotate(player.matrix, -dir);
                    player.pos.x = pos;
                    return;
                }
            }
        }

        function update(time = 0) {
            if (isPaused || isGameOver) return;

            const deltaTime = time - lastTime;
            lastTime = time;

            dropCounter += deltaTime;
            if (dropCounter > dropInterval) {
                playerDrop();
            }

            draw();
            animationId = requestAnimationFrame(update);
        }

        function updateScore() {
            scoreElement.innerText = player.score;
        }

        const arena = createMatrix(12, 20); // 12宽，20高

        const player = {
            pos: {x: 0, y: 0},
            matrix: null,
            next: null, // 下一个方块
            score: 0,
            level: 1,
        };

        // 键盘控制
        document.addEventListener('keydown', event => {
            if (isGameOver) return;
            
            if (event.keyCode === 32) { // Space
                togglePause();
                return;
            }

            if (isPaused) return;

            if (event.keyCode === 37) { // Left
                playerMove(-1);
            } else if (event.keyCode === 39) { // Right
                playerMove(1);
            } else if (event.keyCode === 40) { // Down
                playerDrop();
            } else if (event.keyCode === 38) { // Up (Rotate)
                playerRotate(1);
            }
        });

        // 触屏/按钮控制
        // 使用 touchstart 避免延迟，但要注意 preventDefault 防止滚动
        function addTouchListener(id, action) {
            const btn = document.getElementById(id);
            if (!btn) return;
            
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (isGameOver || (isPaused && action !== togglePause)) return;
                action();
            }, {passive: false});

            // 兼容鼠标点击测试
            btn.addEventListener('mousedown', (e) => {
                if (isGameOver || (isPaused && action !== togglePause)) return;
                action();
            });
        }

        addTouchListener('btn-left', () => playerMove(-1));
        addTouchListener('btn-right', () => playerMove(1));
        addTouchListener('btn-down', () => playerDrop());
        addTouchListener('btn-rotate', () => playerRotate(1));

        // 难度选择
        function selectSpeed(mode) {
            currentSpeedMode = mode;
            initialDropInterval = SPEED_CONFIG[mode].delay;
            
            // 更新UI
            document.querySelectorAll('.diff-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            // 这里的 event.target 可能拿不到，改用遍历匹配文本或其他方式，
            // 简单起见，重新渲染或直接根据点击修改样式。
            // 由于 onclick 传参了，我们直接查找对应按钮
            const buttons = document.querySelectorAll('.diff-btn');
            if (mode === 'slow') buttons[0].classList.add('active');
            if (mode === 'normal') buttons[1].classList.add('active');
            if (mode === 'fast') buttons[2].classList.add('active');

            document.getElementById('speed-desc').innerText = SPEED_CONFIG[mode].label;
        }

        // 游戏流程控制
        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            resetGameLogic();
            update();
        }

        function resetGame() {
            document.getElementById('game-over-screen').style.display = 'none';
            // 显示开始屏幕以重新选择难度
            document.getElementById('start-screen').style.display = 'flex';
        }

        function resetGameLogic() {
            arena.forEach(row => row.fill(0));
            player.score = 0;
            player.level = 1;
            player.next = null; // 重置下一个方块
            // 使用选择的初始速度
            dropInterval = initialDropInterval;
            levelElement.innerText = 1;
            updateScore();
            playerReset();
            isGameOver = false;
            isPaused = false;
            lastTime = 0;
            dropCounter = 0;
        }

        function togglePause() {
            if (isGameOver) return;
            
            isPaused = !isPaused;
            const pauseScreen = document.getElementById('pause-screen');
            
            if (isPaused) {
                pauseScreen.style.display = 'flex';
                cancelAnimationFrame(animationId);
            } else {
                pauseScreen.style.display = 'none';
                lastTime = performance.now(); // 重置时间防止跳帧
                update();
            }
        }
    </script>
</body>
</html>
